const std = @import("std");
const Writer = std.Io.Writer;
const oom = @import("misc").oom;

pub const AnalyzerMsg = union(enum) {
    already_declared: struct { name: []const u8 },
    already_declared_param: struct { name: []const u8 },
    already_declared_field: struct { name: []const u8 },
    assign_to_constant: struct { name: []const u8 },
    assign_to_struct_fn,
    assign_type,
    big_self_outside_decl,
    block_all_path_dont_return,
    break_val_in_non_val_block,
    call_method_on_type: struct { name: []const u8 },
    call_static_on_instance: struct { name: []const u8 },
    cant_continue_scope: struct { name: []const u8 },
    cant_infer_array_type,
    pat_null_non_optional: struct { found: []const u8 },
    dead_code,
    dot_type_on_non_mod: struct { found: []const u8 },
    duplicate_field: struct { name: []const u8 },
    duplicate_param: struct { name: []const u8 },
    enum_dup_tag: struct { name: []const u8 },
    enum_lit_no_type,
    enum_lit_non_enum: struct { found: []const u8 },
    enum_tag_access,
    enum_unknown_decl: struct { @"enum": []const u8, field: []const u8 },
    error_not_in_union: struct { found: []const u8, expect: []const u8 },
    error_with_return: struct { found: []const u8 },
    expect_statement,
    expect_value_found_type: struct { found: []const u8 },
    fallback_err_on_non_err: struct { found: []const u8 },
    fail_no_err: struct { found: []const u8 },
    fail_non_failable,
    fail_outside_fn,
    float_equal,
    fn_expect_value: struct { expect: []const u8 },
    for_iter_non_int_range,
    index_assign_str,
    invalid_arithmetic: struct { found: []const u8 },
    invalid_assign_target,
    invalid_call_target,
    invalid_comparison: struct { found1: []const u8, found2: []const u8 },
    invalid_logical: struct { found: []const u8 },
    invalid_in_type: struct { found: []const u8 },
    invalid_unary: struct { found: []const u8 },
    iter_non_iterable: struct { found: []const u8 },
    match_duplicate_arm,
    match_enum_invalid_pat,
    match_non_literal,
    match_partial_overlap,
    match_non_exhaustive: struct { missing: []const u8 },
    match_no_wildcard,
    match_num_decrease_range,
    match_num_invalid_unary,
    match_unreachable_arm,
    match_wildcard_exhaustive,
    missing_symbol_in_module: struct { symbol: []const u8, module: []const u8 },
    missing_else_clause: struct { if_type: []const u8 },
    missing_field_struct_literal: struct { name: []const u8 },
    missing_file_in_module: struct { file: []const u8 },
    missing_function_param: struct { name: []const u8 },
    named_arg_in_bounded,
    no_continuable_scope,
    no_main,
    non_bool_cond: struct { what: []const u8, found: []const u8 },
    non_indexable_type: struct { found: []const u8 },
    invalid_index: struct { found: []const u8 },
    non_null_comp_optional: struct { found: []const u8 },
    non_struct_field_access: struct { found: []const u8 },
    non_struct_struct_literal,
    null_assign_to_non_optional: struct { expect: []const u8 },
    range_non_num: struct { found: []const u8 },
    range_mix_int_float,
    return_outside_fn,
    self_outside_decl,
    ternary_cond_non_bool: struct { found: []const u8 },
    too_many_fn_args: struct { expect: usize, found: usize },
    too_many_locals,
    too_many_types,
    trap_match_not_ident,
    trap_on_non_error: struct { found: []const u8 },
    type_mismatch: struct { expect: []const u8, found: []const u8 },
    type_not_in_union: struct { expect: []const u8, found: []const u8 },
    undeclared_field_access: struct { name: []const u8 },
    undeclared_block_label: struct { name: []const u8 },
    undeclared_type: struct { found: []const u8 },
    undeclared_var: struct { name: []const u8 },
    unknow_char_escape: struct { found: []const u8 },
    unknown_module: struct { name: []const u8 },
    unknown_param: struct { name: []const u8 },
    unknown_struct_field: struct { name: []const u8 },
    non_comptime_in_global,
    non_comptime_default: struct {
        kind: []const u8,

        pub fn new(kind: enum { field, parameter }) @This() {
            return .{ .kind = @tagName(kind) };
        }
    },
    use_uninit_var: struct { name: []const u8 },
    void_array,
    void_param,
    void_value,

    const Self = @This();

    pub fn getMsg(self: Self, writer: *Writer) !void {
        try switch (self) {
            .already_declared => |e| writer.print("identifier '{s}' is already declared in this scope", .{e.name}),
            .already_declared_field => |e| writer.print("a field named '{s}' already exist in structure declaration", .{e.name}),
            .already_declared_param => |e| writer.print("identifier '{s}' is already used in parameters list", .{e.name}),
            .assign_to_constant => |e| writer.print("can't assign to constant variable '{s}'", .{e.name}),
            .assign_to_struct_fn => writer.writeAll("can't assign to structure's functions"),
            .assign_type => writer.writeAll("trying to assign a type"),
            .big_self_outside_decl => writer.writeAll("can't use 'Self' outside a declaration"),
            .block_all_path_dont_return => writer.writeAll("all paths of block expression don't return a value"),
            .break_val_in_non_val_block => writer.writeAll("can't return a value from this scope"),
            .call_method_on_type => |e| writer.print("method '{s}' called on a type", .{e.name}),
            .call_static_on_instance => |e| writer.print("static function '{s}' called on an instance", .{e.name}),
            .cant_continue_scope => |e| writer.print("block '{s}' isn't continuable", .{e.name}),
            .cant_infer_array_type => writer.writeAll("can't infer array type with empty array and not declared type"),
            .pat_null_non_optional => |e| writer.print("can't use the 'if let' / 'if var' pattern on a non nullable type, found: '{s}", .{e.found}),
            .dead_code => writer.writeAll("unreachable code"),
            .dot_type_on_non_mod => |e| writer.print("can't use a non-module member as a type, found '{s}'", .{e.found}),
            .duplicate_field => |e| writer.print("field '{s}' is already present in structure literal", .{e.name}),
            .duplicate_param => |e| writer.print("parameter '{s}' is already present in function call", .{e.name}),
            .enum_dup_tag => |e| writer.print("tag '{s}' already declared in enum", .{e.name}),
            .enum_lit_no_type => writer.writeAll("can't infer enum's type"),
            .enum_lit_non_enum => |e| writer.print("expect an enum but found '{s}'", .{e.found}),
            .enum_tag_access => writer.writeAll("can't access enum's tag at runtime"),
            .enum_unknown_decl => |e| writer.print("enum '{s}' have no declaration '{s}'", .{ e.@"enum", e.field }),
            .error_not_in_union => |e| writer.print("error '{s}' is not part of union '{s}'", .{ e.found, e.expect }),
            .error_with_return => |e| writer.print("can't return error '{s}' with 'return', use 'fail'", .{e.found}),
            .expect_statement => writer.writeAll("did not expect an expression in this context"),
            .expect_value_found_type => |e| writer.print("expect a value found type '{s}'", .{e.found}),
            .fallback_err_on_non_err => |e| writer.print("expect an error union, found '{s}", .{e.found}),
            .fail_no_err => |e| writer.print("'fail' is used to return errors from functions, found '{s}'", .{e.found}),
            .fail_non_failable => writer.writeAll("can't fail from a non-failable function"),
            .fail_outside_fn => writer.writeAll("fail outside of a function"),
            .float_equal => writer.writeAll("floating-point values equality is unsafe"),
            .fn_expect_value => |e| writer.print("no value returned from function expecting '{s}'", .{e.expect}),
            .for_iter_non_int_range => writer.writeAll("can't iterate a non-int range"),
            .index_assign_str => writer.writeAll("string type does not support indexing assignment"),
            .invalid_arithmetic => |e| writer.print("invalid arithmetic operation on type '{s}'", .{e.found}),
            .invalid_assign_target => writer.writeAll("invalid assignment target"),
            .invalid_call_target => writer.writeAll("invalid call target, can only call functions and methods"),
            .invalid_comparison => |e| writer.print("invalid comparison between types '{s}' and '{s}'", .{ e.found1, e.found2 }),
            .invalid_logical => writer.writeAll("logical operators must be used with booleans"),
            .invalid_in_type => |e| writer.print("can't use 'in' expression with '{s}' type", .{e.found}),
            .invalid_unary => writer.writeAll("invalid unary operation"),
            .iter_non_iterable => |e| writer.print("can't iterate over type '{s}'", .{e.found}),
            .match_duplicate_arm => writer.writeAll("arm is defined multiple times"),
            .match_enum_invalid_pat => writer.writeAll("invalid pattern for matching enums"),
            .match_non_literal => writer.writeAll("expect a constant or a literal in patterns"),
            .match_non_exhaustive => |e| writer.print("non-exhaustive pattern matching, missing: '{s}'", .{e.missing}),
            .match_no_wildcard => writer.writeAll("expect wildcard pattern"),
            .match_num_decrease_range => writer.writeAll("start of range must be less than end"),
            .match_num_invalid_unary => writer.writeAll("unary pattern can only be a negative numeric value"),
            .match_partial_overlap => writer.writeAll("partial arm overlapping"),
            .match_unreachable_arm => writer.writeAll("unreachable arm"),
            .match_wildcard_exhaustive => writer.writeAll("can't use wildcard with an exhaustive pattern match"),
            .missing_symbol_in_module => |e| writer.print("no symbol named '{s}' in module '{s}'", .{ e.symbol, e.module }),
            .missing_else_clause => writer.writeAll("'if' is missing an 'else' clause"),
            .missing_field_struct_literal => |e| writer.print("missing field '{s}' in structure literal", .{e.name}),
            .missing_file_in_module => |e| writer.print("module doesn't contain file '{s}'", .{e.file}),
            .missing_function_param => |e| writer.print("missing argument '{s}'", .{e.name}),
            .named_arg_in_bounded => writer.writeAll("named argument are not allowed with bounded functions"),
            .no_continuable_scope => writer.writeAll("no continuable block found in current scope"),
            .no_main => writer.writeAll("no main function found"),
            .non_indexable_type => |e| writer.print("can't index type '{s}'", .{e.found}),
            .non_bool_cond => |e| writer.print("non boolean condition, found type '{s}'", .{e.found}),
            .invalid_index => |e| writer.print("invalid index type, found '{s}'", .{e.found}),
            .non_null_comp_optional => |e| writer.print("can't compare anything else than 'null' to optional type, found '{s}'", .{e.found}),
            .non_struct_field_access => writer.writeAll("attempting to access a field on a non structure type"),
            .non_struct_struct_literal => writer.writeAll("expect a structure type in structure literal expressions"),
            .null_assign_to_non_optional => |e| writer.print("can't assign 'null' to non-optional type '{s}'", .{e.expect}),
            .range_mix_int_float => writer.writeAll("found a mix of 'int' and 'float' types in range"),
            .range_non_num => |e| writer.print("range values must be 'int' or float, found '{s}'", .{e.found}),
            .return_outside_fn => writer.writeAll("return outside of a function"),
            .self_outside_decl => writer.writeAll("can't use 'self' reserved parameter outside a declaration"),
            .ternary_cond_non_bool => |e| writer.print("ternary's condition must be a boolean, found '{s}'", .{e.found}),
            .too_many_locals => writer.writeAll("too many local variables, maximum is 255"),
            .too_many_fn_args => |e| writer.print("expect maximum {} arguments but found {}", .{ e.expect, e.found }),
            .too_many_types => writer.writeAll("too many types declared, maximum is 268435455"),
            .trap_match_not_ident => writer.writeAll("can only match an identifier"),
            .trap_on_non_error => |e| writer.print("expect an error union type, found `{s}'", .{e.found}),
            .type_mismatch => |e| writer.print("type mismatch, expect type '{s}' but found '{s}' ", .{ e.expect, e.found }),
            .type_not_in_union => |e| writer.print("type `{s}' is not part of union '{s}'", .{ e.found, e.expect }),
            .undeclared_field_access => |e| writer.print("field '{s}' isn't part of structure's definition", .{e.name}),
            .undeclared_block_label => |e| writer.print("no block labelled '{s}' found in scope", .{e.name}),
            .undeclared_type => |e| writer.print("undeclared type '{s}'", .{e.found}),
            .undeclared_var => |e| writer.print("undeclared variable '{s}'", .{e.name}),
            .unknow_char_escape => |e| writer.print("unknow character escape '{s}'", .{e.found}),
            .unknown_module => |e| writer.print("unknown module '{s}'", .{e.name}),
            .unknown_param => |e| writer.print("function doesn't have parameter '{s}'", .{e.name}),
            .unknown_struct_field => |e| writer.print("unknown structure's field '{s}'", .{e.name}),
            .non_comptime_in_global => writer.writeAll("only compilation time expressions are allowed in global scope"),
            .non_comptime_default => |e| writer.print("only compilation time expressions are allowed for {s}", .{e.kind}),
            .use_uninit_var => |e| writer.print("variable '{s}' is used uninitialized", .{e.name}),
            .void_array => writer.writeAll("can't declare an array of 'void' values"),
            .void_param => writer.writeAll("function parameters can't be of 'void' type"),
            .void_value => writer.writeAll("value is of type 'void'"),
        };
    }

    pub fn getHint(self: Self, writer: *Writer) !void {
        try switch (self) {
            .already_declared, .already_declared_field, .already_declared_param => writer.writeAll("this name"),
            .assign_to_constant => writer.writeAll("this variable is declared as a constant"),
            .assign_to_struct_fn => writer.writeAll("this field is a function"),
            .assign_type => writer.writeAll("This is a type, not a value"),
            .big_self_outside_decl => writer.writeAll("this is not a declaration scope"),
            .block_all_path_dont_return => writer.writeAll("this block"),
            .break_val_in_non_val_block => writer.writeAll("can't have this expression"),
            .call_method_on_type, .call_static_on_instance => writer.writeAll("wrong calling convention"),
            .cant_continue_scope, .no_continuable_scope => writer.writeAll("invalid continue"),
            .cant_infer_array_type => writer.writeAll("empty arrays don't convey any type information"),
            .pat_null_non_optional => writer.writeAll("this isn't a nullable type"),
            .dead_code => writer.writeAll("code after this expression can't be reached"),
            .dot_type_on_non_mod => writer.writeAll("this is not a module"),
            .duplicate_field, .duplicate_param => writer.writeAll("this one"),
            .enum_dup_tag => writer.writeAll("this tag"),
            .enum_lit_no_type => writer.writeAll("this expression has no type to infer to"),
            .enum_lit_non_enum => writer.writeAll("this enum literal don't match any enum"),
            .enum_tag_access => writer.writeAll("this is one of the enum's tag"),
            .enum_unknown_decl => writer.writeAll("this name is unknown"),
            .error_not_in_union => writer.writeAll("this is not part of declaration"),
            .error_with_return => writer.writeAll("this is an error"),
            .expect_statement => writer.writeAll("this is an expression"),
            .expect_value_found_type => writer.writeAll("this is not a runtime value"),
            .fallback_err_on_non_err => writer.writeAll("this is not an error union"),
            .fail_non_failable => writer.writeAll("function doesn't return an error union"),
            .float_equal => writer.writeAll("both sides are 'floats'"),
            .fn_expect_value => writer.writeAll("last expression didn't return a value"),
            .for_iter_non_int_range => writer.writeAll("this range is made of floats"),
            .index_assign_str => writer.writeAll("this is a string"),
            .invalid_arithmetic => writer.writeAll("expression is not a numeric type"),
            .invalid_assign_target => writer.writeAll("cannot assign to this expression"),
            .invalid_call_target => writer.writeAll("this is neither a function neither a method"),
            .invalid_comparison => writer.writeAll("expressions have different types"),
            .invalid_logical => |e| writer.print("this expression resolves to a '{s}'", .{e.found}),
            .invalid_in_type => writer.writeAll("invalid type"),
            .invalid_unary, .non_bool_cond => writer.writeAll("expression is not a boolean type"),
            .iter_non_iterable => writer.writeAll("this doesn't have Iterator trait"),
            .match_non_literal => writer.writeAll("this is not a literal"),
            .match_duplicate_arm => writer.writeAll("this case"),
            .match_enum_invalid_pat => writer.writeAll("here"),
            .match_non_exhaustive => writer.writeAll("this expression"),
            .match_no_wildcard => writer.writeAll("non-exhaustive match"),
            .match_num_decrease_range => writer.writeAll("this range is decreasing"),
            .match_num_invalid_unary => writer.writeAll("this pattern"),
            .match_partial_overlap, .match_unreachable_arm => writer.writeAll("this arm"),
            .match_wildcard_exhaustive => writer.writeAll("wildcard useless"),
            .missing_symbol_in_module => writer.writeAll("this symbol is unknown"),
            .missing_else_clause => |e| writer.print("'if' expression is of type '{s}'", .{e.if_type}),
            .missing_field_struct_literal => writer.writeAll("non-exhaustive structure literal"),
            .missing_file_in_module => writer.writeAll("no file matches this name"),
            .missing_function_param, .too_many_fn_args => writer.writeAll("this call"),
            .named_arg_in_bounded => writer.writeAll("this named argument"),
            .no_main => writer.writeAll("in this file"),
            .non_indexable_type => writer.writeAll("not indexable"),
            .non_comptime_in_global, .non_comptime_default => writer.writeAll("this expression"),
            .invalid_index => writer.writeAll("can't be used as an index"),
            .non_null_comp_optional => writer.writeAll("this is not 'null' literal"),
            .non_struct_field_access => |e| writer.print("expect a structure but found '{s}'", .{e.found}),
            .non_struct_struct_literal => writer.writeAll("this is not a structure"),
            .null_assign_to_non_optional => writer.writeAll("this is not an optinal type"),
            .range_mix_int_float => writer.writeAll("range's bound don't share type"),
            .range_non_num => writer.writeAll("this is not a numeric type"),
            .fail_no_err => writer.writeAll("this is not an error"),
            .fail_outside_fn, .return_outside_fn, .self_outside_decl => writer.writeAll("here"),
            .ternary_cond_non_bool => writer.writeAll("this is not a bool"),
            .too_many_locals, .too_many_types => writer.writeAll("this is the exceding one"),
            .trap_match_not_ident => writer.writeAll("this is not an identifier"),
            .trap_on_non_error => writer.writeAll("this is not an error union"),
            .type_mismatch => |e| writer.print("this expression is of type '{s}'", .{e.found}),
            .type_not_in_union => |e| writer.print("this expression is of type '{s}'", .{e.found}),
            .undeclared_field_access, .undeclared_type, .undeclared_var, .use_uninit_var => writer.writeAll("here"),
            .undeclared_block_label => writer.writeAll("this label"),
            .unknow_char_escape => writer.writeAll("unknown character to espace"),
            .unknown_module, .unknown_struct_field => writer.writeAll("this name"),
            .unknown_param, .void_param => writer.writeAll("this parameter"),
            .void_array => writer.writeAll("declared here"),
            .void_value => writer.writeAll("this expression produces no value"),
        };
    }

    pub fn getHelp(self: Self, writer: *Writer) !void {
        try switch (self) {
            .already_declared,
            .already_declared_field,
            .already_declared_param,
            => writer.writeAll("refer to variable's definition to get array's dimension"),
            .assign_to_struct_fn => writer.writeAll("it is not allowed to modify structures' functions at runtime"),
            .assign_to_constant => writer.writeAll(
                "variables declared with 'const' and function parameters are constant, their value can't be changed",
            ),
            .assign_type => writer.writeAll("types aren't assignable to variables"),
            .big_self_outside_decl => writer.writeAll("'Self' can only be used in declarations like enums or structures to refer to the current type"),
            .block_all_path_dont_return => writer.writeAll("when using a block as an expression, all paths must return a value"),
            .break_val_in_non_val_block => writer.writeAll(
                \\you are either trying to return a value from a non expression block (like a 'while' body) or the block
                \\isn't used in an expression
            ),
            .call_method_on_type, .call_static_on_instance => writer.writeAll(
                "static functions can only be called on types and methods can only be called on instances",
            ),
            .cant_continue_scope, .no_continuable_scope => writer.writeAll("'continue' can only be used with 'for' and 'while' statements"),
            .cant_infer_array_type => writer.writeAll(
                \\can't extract any type information from an empty array '[]'. you must either declare a type in variable's
                \\signature like: 'var arr: [int] = []' or initialize the array with at least one value (not possible every time).
                \\Also, doing 'var arr: [int] = []' is equivalent to 'var arr: [int]'.
            ),
            .pat_null_non_optional => writer.writeAll("refer to value's defnintion to see its type or use a regular control flow"),
            .dead_code => writer.writeAll("remove unreachable code"),
            .dot_type_on_non_mod => writer.writeAll("check variable declaration to see it's type"),
            .duplicate_field => writer.writeAll("fields can be defined only once in structure literals"),
            .duplicate_param => writer.writeAll("parameters can be defined only once in function calls"),
            .enum_dup_tag => writer.writeAll("use another name or introduce numbers, underscore, ..."),
            .enum_lit_no_type => writer.writeAll(
                \\to use enum literals, you must provide a type so that the compiler can infer it.
                \\use either: 'var foo: Foo = .a' or 'var foo = Foo.a'"
            ),
            .enum_lit_non_enum => writer.writeAll("enum literal expressions are only allowed with enum types"),
            .enum_tag_access => writer.writeAll(
                \\you can either access declarations inside an enum (functions, constants, ...) or test enum's tag
                \\with an 'if' statement like: 'if foo == .a {}' or with pattern matching via 'match'.
            ),
            .enum_unknown_decl => writer.writeAll("refer to enum's declaration to see available tags and declarations"),
            .error_not_in_union => writer.writeAll("refer to function's declaration to see acceptable errors"),
            .error_with_return => writer.writeAll("'return' keyword is used to write into ok channel and 'fail' writes to the error one"),
            .expect_statement => writer.writeAll(
                \\expressions are allowed inside declarations: functions' bodies, ...
                \\you might be trying to put an expression in global scope for example
            ),
            .expect_value_found_type => writer.writeAll("types can't be used as a runtime value"),
            .fallback_err_on_non_err => writer.writeAll(
                \\fallback operator '!!' is meant to provide a value in case of an error union value is an error
                \\It can't be used with any other type
            ),
            .fail_no_err => writer.writeAll("if you want to return a value, use 'return' instead"),
            .fail_non_failable => writer.writeAll(
                \\'fail' keyword can only be used inside a failable function that defines an error union as
                \\return type
            ),
            .fail_outside_fn => writer.writeAll("fail statements are only allow to exit a function's body with an error"),
            .float_equal => writer.writeAll(
                \\floating-point values are approximations to infinitly precise real numbers. 
                \\   If you want to compare floats, you should compare against an Epsilon, like
                \\   value < 1e-6  instead of  value == 0
                \\   value - other < 1e-6  instead of  value < other
            ),
            .fn_expect_value => writer.writeAll("refer to function's declaration to return the correct type with 'return'"),
            .for_iter_non_int_range => writer.writeAll(
                \\only integer ranges can be used as a for-loop iterator. Ranges made of floats can be used in:
                \\  if:      if value in 1.2..5.6 {}
                \\  pattern: match value {
                \\              1.2..5.6 => ...
                \\           }
            ),
            .index_assign_str => writer.writeAll("strings are immutable, you can't change the underlying data"),
            .invalid_arithmetic => writer.writeAll("expect a numeric type"),
            .invalid_assign_target => writer.writeAll("can only assign to variables"),
            .invalid_call_target => writer.writeAll("change call target to a function or a method or remove the call"),
            .invalid_comparison => writer.writeAll("expressions must have the same type when compared"),
            .invalid_logical => writer.writeAll("modify the logic to operate on booleans"),
            .invalid_in_type => writer.writeAll("can only use 'in' with int and float ranges, arrays and strings"),
            .invalid_unary => |e| writer.print("can only negate boolean type, found '{s}'", .{e.found}),
            .iter_non_iterable => writer.writeAll(
                \\it is only possible to iterate over builtin types array, string, range and maps and over types
                \\that implement the Iterator trait
            ),
            .match_duplicate_arm => writer.writeAll("delete the duplicated arm"),
            .match_enum_invalid_pat => writer.writeAll(
                \\to match on an enum use either enum literals like or direct access on type:
                \\  match shape {
                \\      .circle => ...
                \\      Shape.rectangle => ...
                \\  }
            ),
            .match_non_literal => writer.writeAll("non-constant variables and non-literals aren't a valid pattern"),
            .match_num_decrease_range => writer.writeAll("ranges used as patterns must be increasing. Revert range's bounds"),
            .match_num_invalid_unary => writer.writeAll(
                \\logical unary 'not' is not allowed, use 'true' or 'false' and unary '-' can only be used on numeric values
            ),
            .match_non_exhaustive => writer.writeAll(
                "all pattern matching must be exhaustive. You can use '_' as the last arm to catch all the remaining possibilities",
            ),
            .match_no_wildcard => writer.writeAll("int, float and string types must have a wildcard pattern as is can't be exhaustive"),
            .match_partial_overlap => writer.writeAll(
                \\this arm's patterns are partially covererd by other arms.
                \\In such case, order of declaration of arms matter as the first one will be executed
            ),
            .match_unreachable_arm => writer.writeAll("this arm's patterns are already fully covered by other arms"),
            .match_wildcard_exhaustive => writer.writeAll("can't use wildcard prong with an exhaustive pattern match"),
            .missing_symbol_in_module => writer.writeAll("refer to module's source code or documentation to ge the list of available symbols"),
            .missing_else_clause => writer.writeAll("add an 'else' block that evaluate to the expected type"),
            .missing_field_struct_literal => writer.writeAll(
                "structure literal expressions must provide an expression for all the fields that don't have a default value",
            ),
            .missing_file_in_module => writer.writeAll("check if the file is in the module or if there is a typo"),
            .missing_function_param => writer.writeAll("all non-default-value parameters must be given a value"),
            .named_arg_in_bounded => writer.writeAll(
                \\when bouding a function/method to a variable, you loose default values informations as the bounded function 
                \\could depend on runtime logic.
            ),
            .no_main => writer.writeAll("add a 'main' function that will be called automatically at execution"),
            .non_indexable_type => writer.writeAll(
                \\can only use index syntax '[]' for builtin types array, string and map or types defining the Indexable trait
            ),
            // TODO: when there will be Range, modify
            .invalid_index => writer.writeAll("can only use integer or ranges as index"),
            .non_bool_cond => |e| writer.print("'{s}' conditions can only be boolean type", .{e.what}),
            .non_null_comp_optional => writer.writeAll("replace the compared value with 'null' literal or change the condition"),
            .non_struct_field_access => writer.writeAll("refer to variable's definition to know its type"),
            .non_struct_struct_literal => writer.writeAll("refer to type's definition"),
            .null_assign_to_non_optional => writer.writeAll("only optional types declared with '?' can be assigned 'null'"),
            .range_mix_int_float => writer.writeAll("a range must be made of 'int' or 'float' and both bounds must share the same type"),
            .range_non_num => writer.writeAll(
                \\ranges can only be constructed with numeric values and float ranges can only be used in pattern matching
            ),
            .return_outside_fn => writer.writeAll(
                "return statements are only allow to exit a function's body. In loops, use 'break' otherwise remove the return",
            ),
            .self_outside_decl => writer.writeAll("'self' is a reserved keyword for declaration's instance at runtime"),
            .ternary_cond_non_bool => writer.writeAll("the first expression of a ternary expression is the condition, thus it must be a bool"),
            .too_many_locals => writer.writeAll("it's a compiler's limitation for now. Try changing your code"),
            .too_many_fn_args => writer.writeAll("refer to the function's definition to correct the call"),
            .too_many_types => writer.writeAll("it's a compiler limitation but the code shouldn't anyway have that much types. Try rethink you code"),
            .trap_match_not_ident => writer.writeAll("the 'trap match' syntax expects an identifier to bind the error to match on"),
            .trap_on_non_error => writer.writeAll("'trap' keyword can only interact with error unions"),
            .type_mismatch, .type_not_in_union => writer.writeAll("refer to definition to return the correct type"),
            .undeclared_field_access => writer.writeAll("refer to structure's definition to see available fields or modify it"),
            .undeclared_block_label => writer.writeAll("maybe just a typo?"),
            .undeclared_type => writer.writeAll("consider declaring or importing the type before use"),
            .undeclared_var => writer.writeAll("consider declaring or importing the variable before use"),
            .unknow_char_escape => writer.writeAll("valid escape characters are '\\t', '\\n', '\\\\', '\\r'"),
            .unknown_module => writer.writeAll("create the module first and bring it in project scope (or maybe just a typo?)"),
            .unknown_param => writer.writeAll("refer to function's definition to see available parameters"),
            .unknown_struct_field => writer.writeAll("refer to the structure's declaration to see available fields"),
            .non_comptime_default => writer.writeAll("only compilation time known expressions are allowed for default values"),
            .non_comptime_in_global => writer.writeAll("use a constant expression or initialize the value later in a local scope"),
            .use_uninit_var => writer.writeAll("consider initializing the variable before use"),
            .void_array => writer.writeAll("use any other type to declare an array"),
            .void_param => writer.writeAll("use a any other type than 'void' or remove parameter"),
            .void_value => writer.writeAll("consider returning a value from expression"),
        };
    }
};
