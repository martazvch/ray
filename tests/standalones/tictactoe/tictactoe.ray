enum Marker {
    circle,
    cross,
    none,

    fn toStr(self) -> str {
        return match self {
            .circle => "o"
            .cross => "x"
            .none => " "
        }
    }
}

struct Cell {
    marker: Marker = .none,

    fn mark(self, marker: Marker) {
        if self.marker != .none do print "Already played cell"

        self.marker = marker
    }

    fn toStr(self) -> str {
        return "[" + self.marker.toStr() + "]"
    }
}

struct Grid {
    cells: [[Cell]],

    fn init() -> Self {
        return Self{
            cells: [
                [Cell{}, Cell{}, Cell{}],
                [Cell{}, Cell{}, Cell{}],
                [Cell{}, Cell{}, Cell{}],
            ],
        }
    }

    fn playAt(self, x, y: int, marker: Marker, method = false) {
        if self.cells[x][y].marker != .none {
            print "Already played in this cell"
            return
        }
        
        if method {
            self.cells[x][y].mark(marker)
        } else {
            self.cells[x][y] = Cell{marker}
        }
    }

    fn display(self) {
        var grid = "\n"

        for i, row in self.cells {
            var line = ""

            for j, cell in row {
                line += cell.toStr() + (j < self.cells.len() - 1 ? " " : "")
            }

            grid += line + (i < self.cells.len() - 1 ? "\n" : "")
        }
        
        print grid
    }
}

fn main() {
    var grid = Grid.init()
    
    grid.display()
    grid.playAt(1, 2, .circle)
    grid.display()

    grid.playAt(1, 2, .circle)
    grid.playAt(2, 0, .cross)
    grid.display()

    grid.playAt(1, 0, .circle, true)
    grid.display()

    grid.playAt(1, 1, .cross, method: true)
    grid.display()
}






